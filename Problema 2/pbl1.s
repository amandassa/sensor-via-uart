@ UNIVERSIDADE ESTADUAL DE FEIRA DE SANTANA
@ PROBLEMA 1 - TEC499- MI SISTEMAS DIGITAIS
@ CÓDIGO QUE MAPEIA A UART PL011 DA RASBERRY PI ZERO E A HABILITA PARA RECEBER E TRANSMITIR DADOS SERIAIS
@ SEMESTRE 2022.1
@ AUTORES - ABEL RAMALHO, AMANDA SILVA SANTOS, AURÉLIO BARRETO

@ declaração de constantes
@ SYSCALLS UTILIZADAS
.equ sys_open, 5 @ SYSCALL DE ABERTURA E POSSIBILIDADE DE CRIAR ARQUIVO
.equ sys_mmap2, 192 @ SYSCALL DO SISTEMA LINUX PARA MAPEAMENTO DE MEMÓRIA (GERA ENDEREÇO VIRTUAL)
@ MANIPUALAÇÃO DE ARQUIVOS
.equ S_RDWR, 0666 @ LIBERAR PARA LEITURA E ESCRITA 
.equ pagelen, 4096	@ TAMANHO/PAGINAÇÃO DE MEMÓRIA 
.equ PROT_READ, 1 @ MODO DE LEITURA
.equ PROT_WRITE, 2 @ MODO DE ESCRITA
.equ MAP_SHARED, 1 @ LIBERAR COMPARTILHAMENTO DE MEMÓRIA (PARA NÃO SER DE USO EXCLUSIVO)
.equ O_RDWR,	00000002 @ MODO DE LEITURA E ESCRITA
.equ O_SYNC,	00010000 @ SINCRONIZAÇÃO
@ OFFSETS DOS REGISTRADORES DA UART
.equ UART_CR, 0x30 @ REGISTRADOR DE CONTROLE
.equ UART_FR, 0X18 @ REGISTRADOR DE FLAGS (STATUS DA TRANSMSSÃO)
.equ UART_DR, 0x0  @ REGISTRADOR DE DADOS
.equ UART_LCR, 0x2c @ REGISTRADOR DE LINHA DE CONTROLE (FIFO) 
.equ UART_IBRD, 0x24 @ DIVISOR DE BAUDRATE INTEIRO
.equ UART_FBRD, 0x28 @ DIVIDOR DE BAURDATE FRACIONÁRIO
@ MANIPULAÇÃO DOS BITS DE REGISTRADORES (DESLOCAMENTO)
.equ UART_TXFF, (1<<5) @ CHECAR SE O FIFO ESTÁ CHEIO
.equ #UART_RXFE, (1<<6) @ CHECAR SE A FIFO DE RECEPÇÃO ESTÁ VAZIO
.equ UART_OE, (1<<11) @ overrun error bit
.equ UART_BE, (1<<10) @ break error bit
.equ UART_PE, (1<<9) @ parity error bit
.equ UART_FE, (1<<8 ) @ framing error bit

.equ UART_RXE, (1<<9) @ ATIVAR RECEBIMENTO  EX: (1>>9) DESLOCAR O BIT 1 PARA O NONO(9º) BIT DO REGISTRADOR ESCOLHIDO
.equ UART_TXE, (1<<8) @ ATIVAR TRANSMIÇÃO
.equ UART_UARTEN, (1<<0) @ LIGAR UART
.equ FINALBITS, (UART_RXE|UART_TXE|UART_UARTEN|UART_LPE) @ LIGAR UART, TRANSMISSÃO E RECEPÇÃO AO MESMO TEMPO, LOOPBACK
.equ UART_FIFOCLR, (0<<4) @ DESABILITAR O FIFO
.equ UART_FIFOEN, (1<<4) @ HABILITAR O FIFO
.equ BITS, (UART_WLEN1|UART_WLEN0|UART_FEN|UART_STP2|UART_PEN|UART_PT) @ CONIFUGRAÇÕES DA UART (TAMANHO DO DADO, PARIDADE, STOP BITS E HABILITAR FIFO) 
.equ UART_WLEN1, (1<<6) @ BIT MAIS A DIREITA (MAIS SIGNIFICATIVO) REFRENTE AO TAMANHO DA PALAVRA
.equ UART_WLEN0, (1<<5) @ BIT MAIS A ESQUERDA (MENOS SIGNIFICATIVO) REFERENTE AO TAMANHO DA PALAVRA
.equ UART_FEN, (1<<4) @ HABILITAR FIFO
.equ UART_STP2, (1<<3) @ USAR 2 STOP BITS
.equ UART_PEN, (1<<1) @ LIGAR PARIDADE
.equ UART_PT, (1<<2) @ TIPO DE PARIDADE 0 = ÍMPAR OU 1 = PAR
.equ UART_LPE, (1<<7) @ HABILITAR LOOPBACK INTERNO
.align 2

.data
flags:	.word O_RDWR + O_SYNC
openMode:	.word 0666
devmem: .asciz "/dev/mem" @ DIRETÓRIO USADO PARA MAPEAMENTO DE MEMÓRIA
gpioaddr: .word 0x20200 @ OFFSET BASE DOS GPIO
uartaddr: .word 0x20201 @ OFFSET BASE DA UART PL011
.align 2 

.section .text
.global _start
_start: @ MAPEAMENTO DA MEMÓRIA
	@ ABRINDO ARQUIVO
	ldr r0, =devmem
        ldr r1, =(O_RDWR + O_SYNC)
        mov r7, #sys_open
        svc 0
	@ SEGMENTO DO MAPEAMENTO
 	movs r4, r0 @ fd for memmap
 	
 	BPL 1f @ DIRECIONANDO PARA O LABEL 1:

@ PREPARANDO O MAPEAMENTO
1:  ldr r5, =uartaddr @ ENDEREÇO BASE DA UART/4096 
 	ldr r5, [r5] @ CARREGANDO O VALOR DE R5
 	mov r1, #pagelen @ TAMANHO DA MEMÓRIA QUE PRECISAMOS
 	mov r2, #(PROT_READ + PROT_WRITE) @ HABILITANDO PARA LEITURA E ESCRITA
 	mov r3, #MAP_SHARED @ COMPARTILHAMENTO DE MEMÓRIA
 	mov r0, #0 @ LIMPANDO R0 QUE IRÁ RECEBER O ENDEREÇO VIRTUAL 
 	mov r7, #sys_mmap2 @ CHAMADA DA SYSCALL MMPA2 PARA MAPEAMENDO
 	svc 0 @ CHAMADA DO SERVIÇO
 	movs r8, r0 @ ARMAZENANDO EM R8 NOSSO ENDEREÇO BASE VIRUTAL DA UART

@ DESLIGAR A UART
	mov r0, #0 @ ZERA TODOS OS BITS DE R0
    str r0, [r8, #UART_CR]  @ CARREGA O REGISTRADOR R0 (ZERADO) NO REGISTRADOR UART_CR 
								   @ UART_CR = 0000 0000 0000 0000 0000 0000 0000 0000 	

@ AGUARDAR O FIM DA RECEPÇÃO OU TRANSMISSÃO DO CARACTERE ATUAL (OLHAR FIFO)
loop: 	ldr r2, [r8, #UART_FR] @ CARREGANDO EM R2 O ENDEREÇO DO REGISTRADOR #UART_FR
	    tst r2, #UART_TXFF @ VERIFICAR SE TA CHEIO O FIFO
        bne loop
        
@ LIMPANDO/DESABILITTANDO FIFO
	ldr r1, [r8, #UART_LCR] @ CARREGANDO EM R1 O ENDEREÇO DO REGISTRADOR #UART_FR 
	mov r0, #1 				@ CARREGANDO O BIT 1 EM R0
	lsl r0, #4				@ DESLOCAMENTO A ESQUERDA EM 4 POSIÇÕES (MESMO QUE MULTIPLICAR POR 2^4)
	bic r1, r0				@ LIMPANDO O BIT DESLOCADO (BIC = BIT CLEAR)NO RESGITRADOR R1 
	str r1, [r8, #UART_LCR]	@ CARREGANDO R1 NO REGISTRADOR UART_LCR (LINHA DE CONTROLE)

@ CONFIGURANDO BAUD RATE
	@ CLOCKUART = 3Mhz
	@ BAUDDIV = CLOCKUART/(16xBAUDRATE)
	@ BAUDDIV = CLOCKUART/(16x9600)	= 19,53125
	@ PARTE INTEIRA = 19
	@ PARTE FRACIONÁRIA = 0,53125
	@ PARTE FRACIONÁRIA = (PARTE FRACIONÁRIA * 64) + 0.5 = 34,5	
	mov r0, #0x13   @ 19 EM HEXADECIMAL
	str r0, [r8, #UART_IBRD]
	mov r0, #0x22 @ 34,5 EM HEXADECIMAL
	str r0, [r8, #UART_FBRD]


@ HABILITANDO TX E RX E LIGANDO A UART
	ldr r0, =FINALBITS 
    str r0, [r8, #UART_CR]

@ LIGANDO FIFO, PARIDADE E STOP BITS
	mov r0, #BITS
	str r0, [r8, #UART_LCR]

@ ENVIAR DADO
.macro UART_PUT_BYTE byte
		mov r0, #\byte  @ BYTE DE MENSAGEM A SER ENVIADO PARA A FPGA
	    str r0, [r8, #UART_DR]
		.endm

.macro UART_GET_BYTE:
	getlp: 
		ldr r2,[r8,#UART_FR] @ read the flag resister
		tst r2,#UART_RXFE @ VERIFICAR SE A FIFO DE RECEPÇÃO ESTÁ CHEIA
		bne getlp @ loop while receive FIFO is empty
	ldr r0,[r8,#UART_DR] @ LER O DADO RECEBIDO DO REGISTRADOR DR
	@ *******************PRECISAMOS RETORNAR O DADO ********************* !!!
	tst r0,#UART_OE @ check for overrun error
	bne get_ok1
 @@ handle receive overrun error here - does nothing now

get_ok1:
 tst r0,#UART_BE @ check for break error
 bne get_ok2
 @@ handle receive break error here - does nothing now

get_ok2:
 tst r0,#UART_PE @ check for parity error
 bne get_ok3
 @@ handle receive parity error here - does nothing now

get_ok3:
 tst r0,#UART_FE @ check for framing error
 bne get_ok4
 @@ handle receive framing error here - does nothing now

get_ok4:
  @@ return
mov pc,lr @ return the received character
_end:   mov r0, #0 @ SETANDO 0 PARA SER RETORNADO
        mov r7, #1 @ SYSCALL PARA ENCERRAR A EXECUÇÃO
        svc 0 @ CHAMADA DE SERVIÇO LINUX